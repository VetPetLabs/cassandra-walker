package x

// GENERATED BY XO. DO NOT EDIT.

// XODB is the common interface for database operations that can be used with
//
// This should work with database/sql.DB and database/sql.Tx.
import (
	"database/sql"
	"database/sql/driver"
	"encoding/csv"
	"errors"
	"fmt"
	"ms/sun/shared/config"
	"ms/sun/shared/helper"
	"os"
	"regexp"
	"strings"
)

type XODB interface {
	Exec(string, ...interface{}) (sql.Result, error)
	Query(string, ...interface{}) (*sql.Rows, error)
	QueryRow(string, ...interface{}) *sql.Row
}

// XOLog provides the log func used by generated queries.
var  _sqlLogFile *os.File
var XOLog = func(strings ...interface{}) {
	if config.IS_DEBUG {
        if _sqlLogFile == nil{
            _sqlLogFile,_ = os.OpenFile("./logs/sql_"+helper.IntToStr(helper.TimeNow())+".sql", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        }
        _sqlLogFile.WriteString(fmt.Sprintln(strings...))
        _sqlLogFile.Sync()
	}
 }

func init() {
	go func() {
		for {
			time.Sleep(time.Second)
			if _sqlLogFile != nil {
				_sqlLogFile.Sync()
			}
		}
	}()
}

 var XOLogErr = func(err error) {
    if config.IS_DEBUG && err!= nil{
        if _sqlLogFile == nil {
            _sqlLogFile, _ = os.OpenFile("./logs/sql_"+helper.IntToStr(helper.TimeNow())+".sql", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        }
        _sqlLogFile.WriteString(fmt.Sprintf("/*%v*/\n",err))
        _sqlLogFile.Sync()
    }
}


// ScannerValuer is the common interface for types that implement both the
// database/sql.Scanner and sql/driver.Valuer interfaces.
type ScannerValuer interface {
	sql.Scanner
	driver.Valuer
}

// StringSlice is a slice of strings.
type StringSlice []string

// quoteEscapeRegex is the regex to match escaped characters in a string.
var quoteEscapeRegex = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Scan satisfies the sql.Scanner interface for StringSlice.
func (ss *StringSlice) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid StringSlice")
	}
}
////////////// ME /////////////
type whereClause struct  {
    condition string
    args        []interface{}
}

func whereClusesToSql(wheres []whereClause, whereSep string ) (string, []interface{}) {
    var wheresArr []string
    for _,w := range wheres{
        wheresArr = append(wheresArr,w.condition)
    }
    wheresStr := strings.Join(wheresArr, whereSep)

    var args []interface{}
    for _,w := range wheres{
        args = append(args,w.args...)
    }
    return wheresStr , args
}


